=== main.py ===
import sys
import numpy as np

from PyQt6.QtWidgets import (
    QApplication,
    QMainWindow,
    QFileDialog,
    QWidget,
    QColorDialog,
)
from PyQt6.QtGui import (
    QAction,
    QPainter,
    QImage,
)
from PyQt6.QtCore import Qt, QPoint

from Painter.application_manager import PaintAppManager


class CanvasWidget(QWidget):
    def __init__(self, app_manager: PaintAppManager, parent=None):
        super().__init__(parent)
        self.app_manager = app_manager
        self.setMouseTracking(True)

        # Default brush
        self.brush_size = 20
        self.brush_color = (65535, 0, 0, 65535)


        # main.py (CanvasWidget.__init__)
        self._qimage_cache: QImage | None = None
        self._cache_dirty = True
        self._data8 = None  # will be a preallocated uint8 array matching canvas shape

    def _ensure_qimage_cache(self):
        if not self._cache_dirty and self._qimage_cache is not None:
            return

        try:
            buffer = self.app_manager.render()  # returns the shared render buffer (uint16)
        except RuntimeError:
            self._qimage_cache = None
            self._cache_dirty = False
            return

        h, w, _ = buffer.shape

        # Allocate uint8 buffer once
        if self._data8 is None or self._data8.shape != (h, w, 4):
            self._data8 = np.empty((h, w, 4), dtype=np.uint8)

        # In-place integer right-shift into the preallocated uint8 buffer (no temporaries)
        # np.right_shift supports out=; this writes the shifted values directly into self._data8
        np.right_shift(buffer, 8, out=self._data8, casting='unsafe')

        # Create or reuse QImage that references the uint8 buffer
        if self._qimage_cache is None:
            qimg = QImage(self._data8.data, w, h, 4 * w, QImage.Format.Format_RGBA8888)
            qimg._py_buffer = self._data8
            self._qimage_cache = qimg
        else:
            # If QImage object exists, just update its attached buffer reference to keep GC safe
            self._qimage_cache._py_buffer = self._data8

        self._cache_dirty = False

    def paintEvent(self, event):
        painter = QPainter(self)

        # If render fails, fill white
        if self._cache_dirty:
            self._ensure_qimage_cache()

        if self._qimage_cache is None:
            painter.fillRect(self.rect(), Qt.GlobalColor.white)
            return

        # Draw scaled to widget size
        painter.drawImage(self.rect(), self._qimage_cache)

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            pos = event.position().toPoint()
            self._apply_brush(pos)

    def mouseMoveEvent(self, event):
        if event.buttons() & Qt.MouseButton.LeftButton:
            pos = event.position().toPoint()
            self._apply_brush(pos)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.app_manager.file.canvas.set_active_last_pos(None)

    def _apply_brush(self, pos: QPoint):
        # Map widget coords -> canvas coords using canvas dimensions (avoid full render)
        canvas = self.app_manager.file.canvas
        w = canvas.width
        h = canvas.height

        if w == 0 or h == 0 or self.width() == 0 or self.height() == 0:
            return

        x = int(pos.x() * w / self.width())
        y = int(pos.y() * h / self.height())

        # Draw into the active layer (this mutates the uint16 buffer)
        self.app_manager.draw_brush(x, y, self.brush_size, self.brush_color)

        # Mark cache dirty and request repaint
        self._cache_dirty = True
        self.update()



class MainWindow(QMainWindow):
    """
    Main application window with menus and canvas widget.
    """

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Karanbir Paint")

        self.app_manager = PaintAppManager()
        self.canvas_widget = CanvasWidget(self.app_manager)
        self.setCentralWidget(self.canvas_widget)

        self._create_actions()
        self._create_menu()

        # Start with a new blank document
        self.app_manager.new_document(name="Paint", width=2400, height=3000, filetype="png")
        self.resize(1200, 800)

    def _create_actions(self):
        self.new_action = QAction("New", self)
        self.new_action.triggered.connect(self.new_document)

        self.open_action = QAction("Open…", self)
        self.open_action.triggered.connect(self.open_document)

        self.save_action = QAction("Save", self)
        self.save_action.triggered.connect(self.save_document)

        self.save_as_action = QAction("Save As…", self)
        self.save_as_action.triggered.connect(self.save_document_as)

        self.export_png_action = QAction("Export PNG…", self)
        self.export_png_action.triggered.connect(self.export_png)

        self.color_action = QAction("Choose Color…", self)
        self.color_action.triggered.connect(self.choose_color)

    def _create_menu(self):
        menubar = self.menuBar()

        file_menu = menubar.addMenu("File")
        file_menu.addAction(self.new_action)
        file_menu.addAction(self.open_action)
        file_menu.addAction(self.save_action)
        file_menu.addAction(self.save_as_action)
        file_menu.addSeparator()
        file_menu.addAction(self.export_png_action)

        edit_menu = menubar.addMenu("Edit")
        edit_menu.addAction(self.color_action)

    # ---------- Menu callbacks ----------

    def new_document(self):
        self.app_manager.new_document()
        self.canvas_widget.update()

    def open_document(self):
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Open File",
            "",
            "KSP Files (*.ksp);;PNG Files (*.png);;All Files (*)",
        )
        if path:
            self.app_manager.open_document(path)
            self.canvas_widget.update()

    def save_document(self):
        try:
            self.app_manager.save_document()
        except RuntimeError:
            self.save_document_as()

    def save_document_as(self):
        path, _ = QFileDialog.getSaveFileName(
            self,
            "Save File As",
            "",
            "KSP Files (*.ksp);;All Files (*)",
        )
        if path:
            self.app_manager.save_document(path)

    def export_png(self):
        path, _ = QFileDialog.getSaveFileName(
            self,
            "Export PNG",
            "",
            "PNG Files (*.png);;All Files (*)",
        )
        if path:
            self.app_manager.export_png(path)

    def choose_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            scale = 257  # 255 → 65535
            self.canvas_widget.brush_color = (
                color.red() * scale,
                color.green() * scale,
                color.blue() * scale,
                color.alpha() * scale,
            )

    # ---------- Qt entry ----------


def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()


=== Painter/canvas.py ===
from typing import Iterable, List, Tuple, Optional
import numpy as np
from PyQt6.QtCore import QPoint

from Painter.layers import Layer


import numpy as np
from typing import Union

ArrayLike = Union[np.ndarray]

# Painter/canvas.py (alpha_composite signature)
def alpha_composite(top: np.ndarray, bottom: np.ndarray, out: Optional[np.ndarray] = None) -> np.ndarray:
    if top.shape != bottom.shape:
        raise ValueError("Layer size mismatch")

    dtype = bottom.dtype
    max_val = np.iinfo(dtype).max

    # Promote to uint32 for intermediates (allocate temporaries once if needed)
    top32 = top.astype(np.uint32, copy=False)
    bot32 = bottom.astype(np.uint32, copy=False)

    top_rgb = top32[..., :3]
    top_a_raw = top32[..., 3]
    bot_rgb = bot32[..., :3]
    bot_a_raw = bot32[..., 3]

    opacity = getattr(top, "opacity", 1.0)
    if opacity != 1.0:
        top_a = ((top_a_raw.astype(np.float32) / max_val) * opacity * max_val).astype(np.uint32)
    else:
        top_a = top_a_raw

    top_rgb_p = (top_rgb * top_a) // max_val
    bot_rgb_p = (bot_rgb * bot_a_raw) // max_val

    inv_top_a = max_val - top_a
    out_a = top_a + (bot_a_raw * inv_top_a) // max_val
    out_rgb_p = top_rgb_p + (bot_rgb_p * inv_top_a) // max_val

    out_rgb = np.zeros_like(out_rgb_p, dtype=np.uint32)
    mask = out_a > 0
    if np.any(mask):
        out_rgb[mask] = (out_rgb_p[mask] * max_val) // out_a[mask, None]

    if out is None:
        out = np.empty_like(bottom, dtype=dtype)

    out[..., :3] = np.clip(out_rgb, 0, max_val).astype(dtype)
    out[..., 3] = np.clip(out_a, 0, max_val).astype(dtype)

    return out




def merge_layer_into(top: ArrayLike, bottom_layer_obj) -> None:
    """
    Merge `top` into `bottom_layer_obj` in-place. `bottom_layer_obj` must be a Layer
    instance (so we can use its unlocked() context and assignment).
    """
    # Compute merged pixels using the optimized composite
    merged = alpha_composite(top.pixels if hasattr(top, "pixels") else top,
                             bottom_layer_obj.pixels)

    # Write back into bottom layer in a single assignment inside unlocked()
    with bottom_layer_obj.unlocked():
        bottom_layer_obj[:, :, :] = merged



def merge_layers(layers: List[Layer]) -> Layer:
    """
    Merge a list of layers into the bottom-most one.
    Returns the bottom layer after merging.
    """
    if len(layers) < 1:
        raise ValueError("Need at least one layer to merge")

    bottom = layers[0]
    for top in layers[1:]:
        merge_layer_into(top, bottom)

    return bottom


class Canvas:
    """
    Represents the current working document.

    - Holds layers and the active layer index.
    - Exposes API for tools and the application manager.
    """

    def __init__(self, width: int = 800, height: int = 600, dtype=np.uint16) -> None:
        self._width = int(width)
        self._height = int(height)
        self._dtype = dtype

        self._layers: List[Layer] = []
        self._active_layer_index: int | None = None
        self._render_buf = np.zeros((self._height, self._width, 4), dtype=self._dtype)

    # ---------- Core properties ----------

    @property
    def width(self) -> int:
        return self._width

    @property
    def height(self) -> int:
        return self._height

    @property
    def layers(self) -> List[Layer]:
        """
        Direct access to the list of layers.
        """
        return self._layers

    @property
    def active_layer_index(self) -> int | None:
        return self._active_layer_index

    @property
    def active_layer(self) -> Layer | None:
        if self._active_layer_index is None:
            return None
        if not (0 <= self._active_layer_index < len(self._layers)):
            return None
        return self._layers[self._active_layer_index]

    # ---------- Layer management ----------

    def add_layer(self) -> Layer:
        """
        Append a new layer on top and make it active.
        """
        layer = Layer(self._width, self._height, dtype=self._dtype)
        self._layers.append(layer)
        self._active_layer_index = len(self._layers) - 1
        return layer

    def insert_layer(self, index: int) -> Layer:
        """
        Insert a new layer at a specific index.
        """
        index = max(0, min(index, len(self._layers)))
        layer = Layer(self._width, self._height, dtype=self._dtype)
        self._layers.insert(index, layer)
        self._active_layer_index = index
        return layer

    def remove_layer(self, index: int) -> None:
        """
        Remove a layer by index.
        """
        if not (0 <= index < len(self._layers)):
            raise IndexError("Layer index out of range")
        self._layers.pop(index)
        if not self._layers:
            self._active_layer_index = None
        else:
            self._active_layer_index = min(index, len(self._layers) - 1)

    def move_layer(self, from_index: int, to_index: int) -> None:
        """
        Reorder layers.
        """
        n = len(self._layers)
        if not (0 <= from_index < n):
            raise IndexError("from_index out of range")
        to_index = max(0, min(to_index, n - 1))

        layer = self._layers.pop(from_index)
        self._layers.insert(to_index, layer)

        # Update active index if needed
        if self._active_layer_index == from_index:
            self._active_layer_index = to_index

    def select_layer(self, index: int) -> None:
        """
        Set the active layer.
        """
        if not (0 <= index < len(self._layers)):
            raise IndexError("Layer index out of range")
        self._active_layer_index = index

    def create_layers(self, count: int) -> None:
        """
        Convenience method to create multiple layers.
        """
        for _ in range(count):
            self.add_layer()

    def render_order(self) -> Iterable[Layer]:
        """
        Generator of layers in render order (bottom to top), only visible ones.
        """
        return (layer for layer in self._layers if layer.visible)

    # ---------- Rendering ----------


    # Painter/canvas.py (replace render)
    def render(self) -> np.ndarray:
        if not self._layers:
            return np.zeros((self._height, self._width, 4), dtype=self._dtype)

        visible = [layer for layer in self._layers if layer.visible]
        if not visible:
            return np.zeros((self._height, self._width, 4), dtype=self._dtype)

        # Copy bottom-most visible layer into the preallocated render buffer
        bottom = visible[0].pixels
        np.copyto(self._render_buf, bottom)

        # Composite remaining layers into the same buffer (out=self._render_buf)
        for top in visible[1:]:
            alpha_composite(top.pixels, self._render_buf, out=self._render_buf)

        # Return a view (not a new allocation)
        return self._render_buf

    def merge_visible_layers(self) -> Layer:
        """
        Merge all visible layers into the bottom-most visible layer.
        Returns that layer.
        """
        visible_layers = [layer for layer in self._layers if layer.visible]
        if not visible_layers:
            raise ValueError("No visible layers to merge")

        return merge_layers(visible_layers)

    @property
    def shape(self) -> Tuple[int, ...]:
        if not self._layers:
            return self._height, self._width, 4
        return self._layers[0].shape

    def set_active_last_pos(self, value : QPoint | None) -> None:
        if self._layers and type(value) is QPoint or type(value) is type(None):
            self.layers[self._active_layer_index].last_pos = valueimport numpy as np
from functools import wraps
from contextlib import contextmanager

from PyQt6.QtCore import QPoint


def requires_unlocked(fn):
    """
    Decorator prevents mutation when the layer is locked.
    """
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        if self._locked:
            raise RuntimeError(f"{self.__class__.__name__} is locked")
        return fn(self, *args, **kwargs)
    return wrapper


class Layer:
    """
    A single RGBA layer.

    - Owns pixel data and all pixel-level operations.
    - Canvas and tools call into this class to modify pixels.
    """

    def __init__(self, width: int, height: int, dtype: np.dtype = np.uint16) -> None:
        self._cached_mask = None
        self._width = int(width)
        self._height = int(height)
        self._dtype = dtype

        # Data layout: (H, W, 4) RGBA
        self._max_val = np.iinfo(self._dtype).max
        self._data = np.full((self._height, self._width, 4), dtype=self._dtype, fill_value=self._max_val)
        # Default to white, opaque

        self._visible = True
        self._locked = False
        self._opacity = 1.0
        self._last_pos : QPoint | None = None
        self._cached_brush_size = None

    # ---------- Core properties ----------

    @property
    def width(self) -> int:
        return self._width

    @property
    def height(self) -> int:
        return self._height

    @property
    def shape(self):
        return self._data.shape

    @property
    def dtype(self):
        return self._dtype

    @requires_unlocked
    @dtype.setter
    def dtype(self, dtype: np.dtype):
        """
        Change underlying dtype and convert existing data.
        """
        self._dtype = dtype
        self._data = self._data.astype(dtype)

    @property
    def visible(self) -> bool:
        return self._visible

    @visible.setter
    def visible(self, value: bool):
        self._visible = bool(value)

    @property
    def opacity(self) -> float:
        return self._opacity

    @opacity.setter
    def opacity(self, value: float):
        """
        Clamped opacity to [0, 1].
        """
        self._opacity = float(np.clip(value, 0.0, 1.0))

    @property
    def locked(self) -> bool:
        return self._locked

    @locked.setter
    def locked(self, value: bool):
        self._locked = bool(value)

    # ---------- Lock context ----------

    @contextmanager
    def unlocked(self):
        """
        Temporarily unlock the layer inside a context.
        Useful for engine-level overrides.
        """
        was_locked = self._locked
        self._locked = False
        try:
            yield self
        finally:
            self._locked = was_locked

    # ---------- Pixel access ----------

    def __getitem__(self, key):
        """
        Read-only access to pixel data via slicing.
        """
        return self._data[key]

    @requires_unlocked
    def __setitem__(self, key, value):
        """
        Direct pixel write access via slicing.
        """
        self._data[key] = value

    @property
    def pixels(self) -> np.ndarray:
        """
        Returns a read-only view of the pixel buffer.
        """
        view = self._data.view()
        view.setflags(write=False)
        return view

    @requires_unlocked
    def set_region(self, key, value):
        """
        Convenience method for setting a region of pixels if direct indexing becomes obsolete.
        """
        self._data[key] = value

    # ---------- Utility / info ----------

    def __len__(self):
        return self._width * self._height

    def __iter__(self):
        return iter(self._data)

    def __str__(self):
        return (
            f"{self.__class__.__name__}\n"
            f" Width: {self._width}\n"
            f" Height: {self._height}\n"
            f" Data Type: {self._dtype}"
        )

    # ---------- High-level operations ----------

    @requires_unlocked
    def reset(self, rgba=(255, 255, 255, None)):
        """
        Reset the layer to a solid color.
        If alpha is None, keep existing alpha.
        """
        r, g, b, a = rgba
        self._data[..., 0] = r
        self._data[..., 1] = g
        self._data[..., 2] = b
        if a is not None:
            self._data[..., 3] = a

    @requires_unlocked
    def resize(self, width: int, height: int):
        """
        Resize the layer. For now, this just resets the buffer.
        You can later implement resampling here.
        """
        self._width = int(width)
        self._height = int(height)
        self._data = np.zeros((self._height, self._width, 4), dtype=self._dtype)
        self._data[..., :3] = 255
        self._data[..., 3] = np.iinfo(self._dtype).max

    @requires_unlocked
    def fill(self, rgba: tuple[int, int, int, int]):
        """
        Fill the entire layer with a single RGBA color.
        """
        r, g, b, a = rgba
        self._data[..., 0] = r
        self._data[..., 1] = g
        self._data[..., 2] = b
        self._data[..., 3] = a

    @requires_unlocked
    def draw_brush(self, x: int, y: int, size: int, color: tuple[int, int, int, int]):
        # Cache mask for this brush size
        if self._cached_brush_size != size or self._cached_mask is None:
            r = size // 2
            yy, xx = np.ogrid[-r:r + 1, -r:r + 1]
            self._cached_mask = (xx * xx + yy * yy) <= r * r
            self._cached_brush_size = size
            self._cached_radius = r
        else:
            r = self._cached_radius

        h, w, _ = self._data.shape
        r_c, g_c, b_c, a_c = color

        def stamp(px, py):
            # Compute region bounds
            x_min = max(px - r, 0)
            x_max = min(px + r, w - 1)
            y_min = max(py - r, 0)
            y_max = min(py + r, h - 1)

            region = self._data[y_min:y_max + 1, x_min:x_max + 1]

            # Crop mask to match region shape
            mask = self._cached_mask[
                (y_min - (py - r)):(y_max - (py - r) + 1),
                (x_min - (px - r)):(x_max - (px - r) + 1)
            ]

            region[mask, 0] = r_c
            region[mask, 1] = g_c
            region[mask, 2] = b_c
            region[mask, 3] = a_c

        # Helper: QPoint → (x, y)
        to_xy = lambda qp: (int(qp.x()), int(qp.y()))

        # First point in stroke
        if self.last_pos is None:
            stamp(x, y)
            self.last_pos = QPoint(x, y)
            return

        lx, ly = to_xy(self.last_pos)

        dx = x - lx
        dy = y - ly
        dist = max(abs(dx), abs(dy))

        if dist == 0:
            stamp(x, y)
            self.last_pos = QPoint(x, y)
            return

        # Interpolate between points
        for i in range(dist + 1):
            t = i / dist
            px = int(lx + dx * t)
            py = int(ly + dy * t)
            stamp(px, py)

        self.last_pos = QPoint(x, y)

    @property
    def last_pos(self) -> QPoint:
        return self._last_pos

    @last_pos.setter
    def last_pos(self, pos: QPoint | None) -> None:
        if type(pos) is QPoint:
            self._last_pos = pos
        else:
            self._last_pos = None


